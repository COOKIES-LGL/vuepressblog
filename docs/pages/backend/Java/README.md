---
home: false
sidebar: false
---

- [Maven](./Maven) <span style="color:#bbb; float:right">2024-06-30</span>
- starter 可以快速整合 shiro-redis，配置简单
- lombok：简化代码的工具

### 静态变量特性

Java 中的静态变量是属于类的，而不是对象的实例。因此，当多个线程同时访问一个包含静态变量的类时，需要考虑其线程安全性。

静态变量在内存中只有一份拷贝，被所有实例共享。因此，如果一个线程修改了静态变量的值，那么其他线程在访问该静态变量时也会看到修改后的值。这可能会导致并发访问的问题，因为多个线程可能同时修改静态变量，导致不确定的结果或数据一致性问题。

为了确保静态变量的线程安全性，需要采取适当的同步措施，如同步机制、原子类或 volatile 关键字，以便在多线程环境中正确地读取和修改静态变量的值

### 继承规则

- 父类中声明为 public 的方法在子类中也必须为 public。

- 父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。

- 父类中声明为 private 的方法，不能够被子类继承。

- 父类中的 final 方法可以被子类继承，但是不能被子类重写

- final 类不能被继承，没有类能够继承 final 类的任何特性

- extends 是单一继承、implements 是可以同时继承多个接口（接口跟接口之间采用逗号分隔）

### 抽象方法

- 抽象类可以包含抽象方法和非抽象方法。

- 抽象方法是一种没有任何实现的方法，该方法的具体实现由子类提供。

- 抽象方法不能被声明成 final 和 static。

- 任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。

- 如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法

### volatile 修饰符

volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。  
这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。一个 volatile 对象引用可能是 null。

### StringBuffer、StringBuilder

和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象在使用 StringBuffer 类时，
所以如果需要对字符串进行修改推荐使用 StringBuffer。由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder。

### 方法重载、方法重写

- (1)方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。
- (2)方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。
- 多态性的核心：一个父类类型的引用可以指向其子类的对象，并且在运行时根据对象的实际类型调用相应的方法

#### jdk 国内镜像

https://repo.huaweicloud.com/java/jdk/8u172-b11/
